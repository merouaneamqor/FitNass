generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("MONGO_URL")
}

model User {
  id                 String         @id @default(auto()) @map("_id") @db.ObjectId
  name               String?
  email              String         @unique
  emailVerified      DateTime?
  image              String?
  password           String?
  role               Role           @default(USER)
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  bio                String?
  city               String?
  isVerified         Boolean        @default(false)
  lastLogin          DateTime?
  phoneNumber        String?
  preferences        Json?
  resetPasswordToken String?
  status             UserStatus     @default(ACTIVE)
  tokenExpiry        DateTime?
  verificationToken  String?

  // SaaS Fields
  stripeCustomerId   String?        @unique // Store Stripe Customer ID

  createdClubs       Club[]         @relation("ClubOwner")
  createdGyms        Gym[]          @relation("GymOwner")
  loginHistory       LoginHistory[]
  notifications      Notification[]
  reservations       Reservation[]
  reviews            Review[]
  subscriptions      Subscription[] // Relation to user's subscriptions
  favoriteClubs      Club[]         @relation("UserFavoriteClubs", fields: [favoriteClubIds], references: [id])
  favorites          Gym[]          @relation("UserFavorites", fields: [favoriteGymIds], references: [id])
  trainerProfile     Trainer?       @relation // Add relation back to Trainer (if using userId)

  favoriteClubIds    String[]       @db.ObjectId
  favoriteGymIds     String[]       @db.ObjectId
  ownerClubIds       String[]       @db.ObjectId
  ownerGymIds        String[]       @db.ObjectId
}

model Gym {
  id           String     @id @default(auto()) @map("_id") @db.ObjectId
  name         String     @unique(map: "Gym_name_unique")
  description  String
  address      String
  city         String
  state        String
  zipCode      String
  latitude     Float
  longitude    Float
  phone        String?
  website      String?
  email        String?
  rating       Float      @default(0)
  priceRange   String
  facilities   String[]
  images       String[]
  slug         String?
  citySlug     String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  ownerId      String     @db.ObjectId
  isVerified   Boolean    @default(false)
  status       GymStatus  @default(ACTIVE)
  viewCount    Int        @default(0)
  owner        User       @relation("GymOwner", fields: [ownerId], references: [id])
  promotions   Promotion[]
  reviews      Review[]
  favoritedBy  User[]     @relation("UserFavorites", fields: [favoritedByIds], references: [id])
  classes      FitnessClass[] // Add relation back to FitnessClass

  favoritedByIds String[] @db.ObjectId
}

model Review {
  id          String       @id @default(auto()) @map("_id") @db.ObjectId
  rating      Int
  comment     String
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  userId      String       @db.ObjectId
  gymId       String?      @db.ObjectId
  isHelpful   Int          @default(0)
  status      ReviewStatus @default(PUBLISHED)
  clubId      String?      @db.ObjectId
  club        Club?        @relation("ClubReviews", fields: [clubId], references: [id])
  gym         Gym?         @relation(fields: [gymId], references: [id])
  user        User         @relation(fields: [userId], references: [id])
}

model Promotion {
  id              String          @id @default(auto()) @map("_id") @db.ObjectId
  title           String
  description     String
  startDate       DateTime
  endDate         DateTime
  discount        String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  gymId           String          @db.ObjectId
  redemptionCount Int             @default(0)
  status          PromotionStatus @default(ACTIVE)
  gym             Gym             @relation(fields: [gymId], references: [id])
}

model LoginHistory {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  ipAddress String?
  device    String?
  browser   String?
  location  String?
  createdAt DateTime @default(now())
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Notification {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  title     String
  message   String
  isRead    Boolean  @default(false)
  type      String
  createdAt DateTime @default(now())
  userId    String   @db.ObjectId
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Club {
  id            String       @id @default(auto()) @map("_id") @db.ObjectId
  name          String
  description   String
  address       String
  city          String
  state         String
  zipCode       String
  latitude      Float
  longitude     Float
  phone         String?
  website       String?
  email         String?
  rating        Float        @default(0)
  images        String[]
  facilities    String[]
  openingHours  Json?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  ownerId       String       @db.ObjectId
  isVerified    Boolean      @default(false)
  status        ClubStatus   @default(ACTIVE)
  viewCount     Int          @default(0)
  owner         User         @relation("ClubOwner", fields: [ownerId], references: [id])
  reviews       Review[]     @relation("ClubReviews")
  sportFields   SportField[]
  favoritedBy   User[]       @relation("UserFavoriteClubs", fields: [favoritedByIds], references: [id])
  classes       FitnessClass[] // Add relation back to FitnessClass

  favoritedByIds String[]    @db.ObjectId
}

model SportField {
  id           String         @id @default(auto()) @map("_id") @db.ObjectId
  name         String
  description  String
  type         SportFieldType
  surface      String?
  indoor       Boolean        @default(false)
  size         String?
  maxCapacity  Int?
  pricePerHour Float // Changed from Decimal
  currency     String         @default("MAD")
  availability Json?
  amenities    String[]
  images       String[]
  clubId       String         @db.ObjectId
  status       FieldStatus    @default(AVAILABLE)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  reservations Reservation[]
  club         Club           @relation(fields: [clubId], references: [id], onDelete: Cascade)
}

model Reservation {
  id               String            @id @default(auto()) @map("_id") @db.ObjectId
  startTime        DateTime
  endTime          DateTime
  status           ReservationStatus @default(PENDING)
  totalPrice       Float // Changed from Decimal
  userId           String            @db.ObjectId
  sportFieldId     String            @db.ObjectId
  paymentStatus    PaymentStatus     @default(UNPAID)
  paymentId        String?
  notes            String?
  participantCount Int?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  sportField       SportField        @relation(fields: [sportFieldId], references: [id])
  user             User              @relation(fields: [userId], references: [id])
}

model SubscriptionPlan {
  id            String         @id @default(auto()) @map("_id") @db.ObjectId
  name          String         // e.g., "Basic", "Pro", "Enterprise"
  tier          PlanTier       @default(BASIC) // Enum for plan level
  description   String
  price         Float          // Price per billing cycle
  billingCycle  BillingCycle   // Monthly, Annually, etc.
  features      String[]       // List of included features
  maxGyms       Int?           // Limit for gym owners
  maxClubs      Int?           // Limit for club owners
  maxLocations  Int?           // Limit for multi-location businesses
  analyticsLevel PlanAnalyticsLevel @default(NONE)
  supportLevel  PlanSupportLevel   @default(BASIC)
  isActive      Boolean        @default(true) // To easily enable/disable plans
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  subscriptions Subscription[] // Relation to subscriptions using this plan
}

model Subscription {
  id                  String             @id @default(auto()) @map("_id") @db.ObjectId
  userId              String             @db.ObjectId // Link to the User
  planId              String             @db.ObjectId // Link to the SubscriptionPlan
  status              SubscriptionStatus @default(ACTIVE) // Active, PastDue, Cancelled, etc.
  startDate           DateTime
  endDate             DateTime?          // Can be null for ongoing subscriptions
  trialEndDate        DateTime?          // End date for free trials
  autoRenew           Boolean            @default(true)
  paymentMethodId     String?            // Reference to payment method (e.g., Stripe PaymentMethod ID)
  stripeSubscriptionId String?           @unique // Store Stripe Subscription ID
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  payments            PaymentRecord[]    // History of payments for this subscription
  plan                SubscriptionPlan   @relation(fields: [planId], references: [id])
  user                User               @relation(fields: [userId], references: [id])
}

model PaymentRecord {
  id             String       @id @default(auto()) @map("_id") @db.ObjectId
  subscriptionId String       @db.ObjectId
  amount         Float
  status         String
  paymentMethod  String
  transactionId  String?
  createdAt      DateTime     @default(now())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
}

model Trainer {
  id           String    @id @default(auto()) @map("_id") @db.ObjectId
  name         String
  bio          String?
  specialties  String[]  // e.g., ["Yoga", "Weightlifting", "Pilates"]
  certifications String[] // Corrected: Required list (can be empty)
  city         String?   // To link trainers to locations directly
  // OR Link trainers to specific Gyms/Clubs instead/also?
  // gymId        String?   @db.ObjectId
  // gym          Gym?      @relation(fields: [gymId], references: [id])
  // clubId       String?   @db.ObjectId
  // club         Club?     @relation(fields: [clubId], references: [id])
  userId       String?   @db.ObjectId @unique // Optional: Link to a User account if trainers can log in
  user         User?     @relation(fields: [userId], references: [id])
  rating       Float?    @default(0)
  images       String[]
  phone        String?
  email        String?   @unique // Maybe unique?
  website      String?
  hourlyRate   Float?    // Or price range
  status       TrainerStatus @default(ACTIVE) // Active, Inactive, Pending Verification
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  classes      FitnessClass[] @relation("ClassTrainer") // Relation to classes taught by this trainer
  // Add relations to Reviews, Bookings/Schedules if needed later
}

model FitnessClass {
  id             String     @id @default(auto()) @map("_id") @db.ObjectId
  name           String     // e.g., "Morning Vinyasa Yoga"
  description    String
  type           String     // e.g., "Yoga", "HIIT", "Spinning", "Zumba" (Used for filtering)
  difficulty     String?    // e.g., "Beginner", "Intermediate", "Advanced"
  duration       Int        // Duration in minutes
  schedule       Json?      // Could store complex recurrence rules (e.g., iCal RRULE) or simple date/time list
  startTime      DateTime?  // For single-occurrence classes
  endTime        DateTime?  // For single-occurrence classes
  capacity       Int?
  price          Float?
  currency       String?    @default("MAD")
  gymId          String?    @db.ObjectId // Link to Gym offering the class
  gym            Gym?       @relation(fields: [gymId], references: [id])
  clubId         String?    @db.ObjectId // Link to Club offering the class
  club           Club?      @relation(fields: [clubId], references: [id])
  trainerId      String?    @db.ObjectId // Optional: Link to the specific trainer teaching
  trainer        Trainer?   @relation("ClassTrainer", fields: [trainerId], references: [id])
  images         String[]
  status         ClassStatus @default(ACTIVE) // Active, Cancelled, Full
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  // Add relations to Bookings/Reservations if needed later
}

enum Role {
  USER
  ADMIN
  GYM_OWNER
  CLUB_OWNER
}

enum UserStatus {
  ACTIVE
  INACTIVE
  PENDING
  SUSPENDED
  BANNED
}

enum GymStatus {
  ACTIVE
  INACTIVE
  PENDING_APPROVAL
  CLOSED
}

enum ReviewStatus {
  PUBLISHED
  PENDING
  REJECTED
  DELETED
}

enum PromotionStatus {
  ACTIVE
  SCHEDULED
  EXPIRED
  CANCELLED
}

enum SportFieldType {
  FOOTBALL
  TENNIS
  BASKETBALL
  VOLLEYBALL
  SQUASH
  PADEL
  SWIMMING_POOL
  GOLF
  OTHER
}

enum FieldStatus {
  AVAILABLE
  UNDER_MAINTENANCE
  CLOSED
  UNAVAILABLE
}

enum ClubStatus {
  ACTIVE
  INACTIVE
  PENDING_APPROVAL
  CLOSED
}

enum ReservationStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

enum PaymentStatus {
  UNPAID
  PAID
  REFUNDED
  PARTIALLY_REFUNDED
  FAILED
}

enum BillingCycle {
  MONTHLY
  QUARTERLY
  ANNUALLY
  ONE_TIME // For potential lifetime deals etc.
}

enum SubscriptionStatus {
  ACTIVE
  TRIALING
  PAST_DUE
  CANCELLED // User cancelled, active until period end
  EXPIRED   // Period ended after cancellation or non-renewal
  INCOMPLETE // Payment failed during signup
  INCOMPLETE_EXPIRED // Payment failed and grace period passed
}

enum PlanTier {
  FREE
  BASIC
  PRO
  ENTERPRISE
}

enum PlanAnalyticsLevel {
  NONE
  BASIC
  ADVANCED
}

enum PlanSupportLevel {
  NONE
  BASIC
  PRIORITY
  DEDICATED
}

enum TrainerStatus {
  ACTIVE
  INACTIVE
  PENDING
}

enum ClassStatus {
  ACTIVE
  CANCELLED
  FULL
  PENDING // Maybe needs approval
}
